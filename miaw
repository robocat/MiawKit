#!/usr/bin/ruby

require 'set'
require 'optparse'

class Miaw

  def read_strings_files()
    @tables = []
    @strings = {}
    @lang_count = 0
    @all_langs = []

    Dir.glob("**/*.lproj/*.strings").each do |filename|
      if filename.start_with?("Pods") || filename.start_with?("Carthage")
        next
      end

      if @opts[:verbose]
        puts "Processing: #{ filename }"
      end

      table_basename = File.basename(filename, ".strings")
      if not @tables.include? table_basename
        @tables << table_basename
      end
      
      lang = filename[/[^\.]*/].split("/").last
      
      File.open(filename, "r:UTF-8") do |f|
        contents = f.read
        contents.scan(/^\s*\"(.*)\"\s*=\s*\"(.*)\";/) do |key, value|
          key = key.split().join("_")

          @strings[key] ||= {}
          @strings[key][lang] = value
        end
      end
    end

    @strings.each do |key, value|
      if (value.count > @lang_count) then
        @lang_count = value.count
        @all_langs = value.keys
      end
    end
  end

  def generate_swift_file()
    f = File.open("#{ @opts[:output] }/LocalizationKeys.swift", "w")
    f.write("// Header automatically generated by MiawKit. Do not edit.\n")
    if @opts[:includes_date]
      f.write("// Generated on #{ Time.now.asctime }\n")
    end
    f.write("\n")
    f.write("import Foundation\n");
    f.write("\n")

    @tables.each do |table|
      f.write("/**\n")
      f.write("    #{ table } strings file \n")
      f.write("*/\n")
      f.write("let #{ table } = \"#{ table }\"\n\n")
    end

    @strings.each do |key, value|
      if (value.count != @lang_count) and @opts[:warnings] then
        missing_langs = @all_langs.inject([]) { |a, v| if not value.keys.include? v then a << v else a end }
        f.write("// FIXME: Missing languages #{ missing_langs.join(', ') } for key '#{key}'\n");
      end

      f.write("/**\n")
    
      value.each do |lang, desc|
        if (lang == @opts[:default_language]) then
          f.write("    \"#{ desc }\"\n\n")
        end
      end
    
      f.write("    All translations:\n\n")
    
      value.each do |lang, desc|
        f.write("    @b #{ lang }@: \"#{ desc }\"\n\n")
      end
    
      f.write("*/\n")
      f.write("let #{key.gsub("%", "").gsub("@", "X").gsub(".", "_").gsub(/^[\d]/, 'n\0')} = \"#{ key }\"\n\n")
    end

    f.write("\n")

    f.close()
  end

  def generate_objc_file()
    f = File.open("#{ @opts[:output] }/MKLocalizationKeys.h", "w")
    f.write("// Header automatically generated by MiawKit. Do not edit.\n")
    if @opts[:includes_date]
      f.write("// Generated on #{ Time.now.asctime }\n")
    end
    f.write("\n")
    f.write("#import <Foundation/Foundation.h>\n");
    f.write("\n")
    f.write("#ifndef MK_LOCALIZATION_KEYS\n")
    f.write("#define MK_LOCALIZATION_KEYS\n")
    f.write("\n")

    @tables.each do |table|
      f.write("/*!\n")
      f.write(" * #{ table } strings file \n")
      f.write(" */\n")
      f.write("static NSString * const #{ table } = @\"#{ table }\";\n\n")
    end

    @strings.each do |key, value|
      if (value.count != @lang_count) and @opts[:warnings] then
        missing_langs = @all_langs.inject([]) { |a, v| if not value.keys.include? v then a << v else a end }
        f.write("#warning Missing languages #{ missing_langs.join(', ') } for key '#{key}'\n");
      end

      f.write("/*!\n")
    
      value.each do |lang, desc|
        if (lang == @opts[:default_language]) then
          f.write(" * \"#{ desc }\"\n\n")
        end
      end
    
      f.write(" * All translations:\n\n")
    
      value.each do |lang, desc|
        f.write(" * @b #{ lang }@: \"#{ desc }\"\n\n")
      end
    
      f.write(" */\n")
      f.write("static NSString * const #{key.gsub("%", "").gsub("@", "X").gsub(".", "_").gsub(/^[\d]/, 'n\0')} = @\"#{ key }\";\n\n")
    end

    f.write("                                               \n")
    f.write("#endif                                         \n")

    f.close()
  end

  def generate_keys_file(opts)
    @opts = opts
    read_strings_files()

    if @opts[:swift] then
      generate_swift_file()
    end

    if @opts[:objc] then
      generate_objc_file()
    end
  end
end

options = { :output => ".",
            :default_language => "en",
            :verbose => false,
            :includes_date => true,
            :warnings => true,
            :swift => false,
            :objc => false,
            :generate => true }
gopts = nil
OptionParser.new do |opts|
  opts.banner = "Usage: #{ $PROGRAM_NAME } -g [options]"
  opts.on("-oPATH", "--output=PATH", String, "Specify output path.") do |o|
    if !File.directory?(o)
      puts "Specified output directory does not exist: #{ o }"
      exit
    end
    options[:output] = o
  end

  opts.on("--swift", "Generates a Swift file") do |g|
    options[:swift] = true
  end

  opts.on("--objc", "Generates a Objective-C header file") do |g|
    options[:objc] = true
  end

  opts.on("--dry-run", "Only parses .strings files and does not modify any files.") do |g|
    options[:generate] = false
  end

  opts.on("-w", "--nowarn", "Skips warnings for missing strings.") do |g|
    options[:warnings] = false
  end

  opts.on("-l", "--language", "Code of your development language. Default is en.") do |l|
    options[:default_language] = l
  end

  opts.on("-d", "--no-date", "Removes the date from the header.") do |d|
    options[:includes_date] = d
  end

  opts.on("-v", "--verbose", "Set verbosity.") do |v|
    options[:verbose] = v
  end

  opts.on("-h", "--help", "Displays this information.") do
    puts opts
    exit
  end

  gopts = opts
end.parse!

if options.has_key?(:generate) then
  miaw = Miaw.new()
  miaw.generate_keys_file(options)
else
  puts gopts
end
